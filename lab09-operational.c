#pragma config(Motor,  motorA,          J1,            tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          J2,            tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define LENGTH 41
#define TF -0.25
#define J1_INIT 0
#define J2_INIT 180

#define J1_SCALE -3.68 //done tuning
#define J2_SCALE 3.75 	//needs to be tuned

//int path_lengths[3] = {1, 1, 1};

//(-6,1)
#define LENGTH_1 49
int path_1[LENGTH_1][2] = {{13,146},
{20,133},
{27,122},
{31,113},
{34,105},
{37,97},
{39,90},
{42,83},
{44,77},
{46,71},
{48,65},
{49,59},
{51,53},
{52,48},
{58,43},
{65,40},
{72,38},
{81,36},
{90,36},
{98,38},
{107,40},
{112,38},
{118,36},
{124,35},
{131,41},
{54,-41},
{59,-42},
{65,-43},
{70,-45},
{74,-48},
{79,-50},
{83,-54},
{87,-57},
{91,-61},
{94,-65},
{98,-69},
{102,-74},
{105,-79},
{109,-84},
{112,-90},
{116,-95},
{119,-102},
{123,-109},
{128,-112},
{133,-117},
{139,-123},
{145,-130},
{151,-139},
{159,-152},
};

//(4, 4)
#define LENGTH_2 40
int path_2[LENGTH_2][2] = {{153,-137},
{148,-125},
{144,-116},
{140,-107},
{137,-99},
{134,-92},
{131,-86},
{129,-79},
{126,-73},
{124,-67},
{122,-62},
{120,-56},
{118,-51},
{116,-45},
{114,-40},
{107,-38},
{98,-36},
{89,-36},
{81,-38},
{72,-40},
{67,-38},
{61,-36},
{55,-35},
{131,41},
{125,41},
{120,42},
{114,43},
{109,45},
{105,48},
{100,50},
{96,54},
{92,57},
{88,61},
{85,65},
{83,73},
{80,82},
{77,92},
{74,102},
{70,114},
{65,128},
};

//(6, 0)
#define LENGTH_3 16
int path_3[LENGTH_3][2] = {{66,121},
{66,115},
{66,109},
{65,104},
{64,99},
{63,95},
{62,92},
{60,89},
{55,92},
{49,96},
{44,101},
{39,107},
{33,114},
{27,122},
{20,133},
{13,146},
};

void goToTheta(int t1, int t2){ //puts joints at desired theta one and theta two

	int tick = 0; //encoder ticks, used for joint 2 offset

	while(nMotorEncoder(J1)!= round(J1_SCALE*(t1-J1_INIT)) || nMotorEncoder(J2)!= round(J2_SCALE*(t2-J2_INIT)) + round(J1_SCALE*(t1-J1_INIT)*TF)){ //while both joints are not at the desired location
		//nxtDisplayString(4,"%d",tick);

		nxtDisplayClearTextLine(5);
		nxtDisplayClearTextLine(6);
		nxtDisplayString(5,"%d",nMotorEncoder(J1));
		nxtDisplayString(6,"%d",nMotorEncoder(J2));

		tick = tick + 1; //increment encoder tick

		if(nMotorEncoder(J1) < round(J1_SCALE*(t1-J1_INIT))){ //if motor encodes is less than desired
				motor[J1] = 10; //go forewards
				//if(tick % 4 == 0){ //add offset to second joint to offset backlash
					//t2 = t2 + 1;
				//}
		}
		else if(nMotorEncoder(J1) > round(J1_SCALE*(t1-J1_INIT))){ //if greater
				motor[J1] = -10; //go backwards
				//if(tick % 4 == 0){ //add offset to second joint to offset backlash
					//t2 = t2 - 1;
				//}
		}
		else{				//if equal
				motor[J1] = 0; //stop
		}
		//nxtDisplayString(7,"%d",t2);
		if(nMotorEncoder(J2) < round(J2_SCALE*(t2-J2_INIT)) + round(J1_SCALE*(t1-J1_INIT)*TF)){ //same thing but for the other motor
				motor[J2] = 10;
				nxtDisplayString(7,"1");
		}
		else if(nMotorEncoder(J2) > round(J2_SCALE*(t2-J2_INIT)) + round(J1_SCALE*(t1-J1_INIT)*TF)){
				motor[J2] = -10;
				nxtDisplayString(7,"2");
		}
		else{
				nxtDisplayString(7,"3");
				motor[J2] = 0;
		}
	}
	motor[J1] = 0; //stops both motors
	motor[J2] = 0;
}

task main()
{
	nMotorEncoder(J1) = 0; //reset encoders
	nMotorEncoder(J2) = 0;
	goToTheta(15, 147);
	for(int i = 0; i< LENGTH_1; i++){
		goToTheta((int)path_1[i][0], (int)path_1[i][1]); //for each angle pair, go to said angles
	}
	wait10Msec(300);
	for(int i = 0; i< LENGTH_2; i++){
		goToTheta((int)path_2[i][0], (int)path_2[i][1]); //for each angle pair, go to said angles
	}
	wait10Msec(300);
	for(int i = 0; i< LENGTH_3; i++){
		goToTheta((int)path_3[i][0], (int)path_3[i][1]); //for each angle pair, go to said angles
	}
	wait10Msec(300);

	while(1){ //just displays encoder values
		nxtDisplayClearTextLine(5);
		nxtDisplayClearTextLine(6);
		nxtDisplayString(5,"%d",nMotorEncoder(J1));
		nxtDisplayString(6,"%d",nMotorEncoder(J2));

	};
}
